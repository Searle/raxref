#!/usr/bin/perl

# Raxref - Simple, lightweight and fast Cross Referencing

# Like MXR, LXR and LXRng, but with much more KISS

# Author: Dietrich Raisin, info1@raisin.de
# License: see LICENSE file

use warnings;
use strict;

use Getopt::Long 2.24 qw( :config auto_version bundling );
use Pod::Usage;
use File::Copy;
use DB_File;
use POSIX qw( ceil );
use Cwd qw( cwd abs_path );

use Data::Dumper;

our $VERSION= '0.1';

# TODO: Doc
my $have_zlib;

# Zlib not yet NOT IMPLEMENTED
# BEGIN {
#     eval { require Compress::Raw::Zlib; };
#     unless ($@) {
#         $have_zlib= 1;
#         import Compress::Raw::Zlib;
#     }
# }

our $opt_quiet;
our $opt_conf;
our $opt_source;
our $opt_all;
our $opt_outpath;
our $opt_help;
our $opt_man;
our $opt_zip;

GetOptions( "quiet|q", "conf|c=s", "source|s=s", "all|a", "outpath|o=s", "zip|z", "help|h", "man|m" ) or pod2usage(2);
pod2usage(-verbose => 1) if $opt_help;
pod2usage(-verbose => 2) if $opt_man;

# TODO: Doc
my $project_name;
my $project_title;
my @project_info;
my %ftypes;
my $output_path;
my $token_threshold;

# Contains: $sources[$source]= $path
my %sources;
my $default_source;

# Contains: See read_conf()
my %sections;
my @sections;

# Tied DB_File handles for caches
my %file_cache;

# List of sections to be built
my %build_sections;

# List of sections that must be re-analyzed because files changed
my %analyze_sections;

###############################################################################
#
#       TOOLS
#
###############################################################################

sub mtime {
    return (stat($_[0]))[9] || 0;
}

{
    my $last_text= '';

    sub printx {
        my $text= join('', @_);

        return if $opt_quiet;

        local $|= 1;
        print "\r", " " x length($last_text), "\r", $text;
        $last_text= $text;
    }

    sub printnl {
        my $text= join('', @_);

        return if $opt_quiet;

        printx();
        print "$text\n";
    }
}

# DEBUG: For checking memory consumption
# sub die2 {
#     print STDERR "OK!\n"; <STDIN>; die;
# }

# TODO: Implement some sort of warning if file can't be read
sub read_file {
    my $file= shift;
    local $/= undef;
    my $fin;
    open $fin, $file or return "";
    my $result= <$fin>;
    close $fin;
    return $result;
}

sub zip_file {
    my $file= shift;
    `gzip -9 -c "$file" > "$file.gz"`;
}

sub write_file {
    my $file= shift;
    my $content= shift;
    my $zip_it= shift;

    my $fout;
    open $fout, ">$file" or die "Can't write '$file'";
    print $fout $content;
    close $fout;

    zip_file($file) if $zip_it;
}

sub jsify {
    my $text= shift;
    $text =~ s/'/\\'/g;
    return $text;
}

###############################################################################
#
#       Read Configuration
#
###############################################################################

sub get_repo_info {
    my $repo_type= shift;
    my $path= shift;

    my %info;

    my $old_path= cwd();
    chdir $path or return { error => "Can't chdir to '$path'" };

    if ($repo_type eq 'svn') {
        my $info= `svn info`;
        $info =~ /^Revision:\s+(\S+)/m;
        $info{'version'}= "Revision $1" if $1;
    }
    if ($repo_type eq 'git') {
        my $info= `git log | head -n 3`;
        $info =~ /^Date:\s+(\S+)/m;
        $info{'version'}= $1 if $1;
    }
    chdir $old_path;

    return { error => "No version info found" } unless $info{'version'};
    return \%info;
}

sub init {

    # Reset all data
    $project_name= undef;
    $project_title= undef;
    @project_info= ();
    %ftypes= ();
    $output_path= $opt_outpath;
    %sources= ();
    $default_source= undef;
    %sections= ();
    @sections= ();
    %build_sections= ();
    %analyze_sections= ();
    $token_threshold= 0.85;        # 0.1 .. 1
}

sub read_conf {
    my $file= shift;
    my $content= shift;

    # Config files to include
    my %files= ($file => 0);

    my $new_section= sub {
        $sections{$_[0]}= {
            title => $_[1],
            omit => $_[2],
            includes => [],
            # TODO: Implement: excludes => [],
            files => [],
            tokens => {},
            index => scalar @sections,
        };
        push @sections, $_[0] unless defined $_[3];
    };

    my $new_ftype= sub {
        $ftypes{$_[0]}= {
            title => $_[1],
            files_re => '\/\/$',   # Never matches
            keywords => [],
            tokens_include_re  => '[a-zA-Z][a-zA-Z0-9_]+',
            tokens_exclude_re  => undef,
        };
    };

    my $include;             # "my $sub= sub { $sub->() }" doesn't work in perl 5
    $include= sub {
        my $file= shift;
        my $content= shift;

        $files{$file}= 1;    # mark as included

        my $section;
        my $ftype;
        my $line_i= 0;
        my $line;

        my $err= sub {
            my $message= shift;

            # TODO: Do something saner than exiting, perhaps...
            printnl("ERROR in '$file', line $line_i:\n  $message!\n  The current line is '$line'");
            return 1;
        };

        my $warn= sub {
            my $message= shift;
            printnl("WARNING in '$file', line $line_i:\n  $message!\n The current line is '$line'");
        };

        my $not_void_context= sub {
            return $err->("Not valid inside 'section' declaration") if $section;
            return $err->("Not valid inside 'filetype' declaration") if $ftype;
            return 0;
        };

        my $not_section_context= sub {
            return $err->("'section' declaration missing") unless $section;
            return $err->("Not valid inside 'filetype' declaration") if $ftype;
            return 0;
        };

        my $not_ftype_context= sub {
            return $err->("'filetype' declaration missing") unless $ftype;
            return $err->("Not valid inside 'section' declaration") if $section;
            return 0;
        };

        $content= read_file($file) if $file;
        return 2 if $content eq "";

        for (split(/\n\r?/, $content)) {
            $line= $_;
            $line_i++;

            # Kill trailing white space and comments. Comments must start at beginning of line
            # or have one white space before '#' to enable '#' in values.
            $line =~ s/\s+(?:#.*)?$//;
            next if $line eq '' || $line =~ /^#/;

            # Any context

            if ($line =~ /^include\s+(.*)$/) {
                $warn->("File '$1' already included. Ignored."), next if $files{$1};

                # TODO: Support ~/...
                return $err->("Error in included file") if $include->($1);
                next;
            }

            # Void context

            if ($line =~ /^project\s+([A-Za-z][A-Za-z0-9_]*)\s+(.+)$/) {
                return 1 if $not_void_context->();

                if ($project_name) {
                    $warn->("Extra 'project' directive ignored");
                    next;
                }
                $project_name= $1;
                $project_title= $2;
                next;
            }
            if ($line =~ /^info\s+(.+)$/) {
                return 1 if $not_void_context->();

                push @project_info, $1;
                next;
            }
            if ($line =~ /^zip$/) {
                return 1 if $not_void_context->();

                # untested :-/
                $opt_zip= 1;
                next;
            }
            if ($line =~ /^source\s+([A-Za-z][A-Za-z0-9_]*)\s+(\S+)(\s+([a-z]+))?$/) {
                return 1 if $not_void_context->();

                my ($name, $path, $repo_type)= ($1, $2, $4);
                $path =~ s/^~/$ENV{HOME}/;
                return $err->("Source already defined") if $sources{$name};
                return $err->("Source path '$path' is not a directory") unless -d $path;
                return $err->("Repository type not supported. Supported: git, svn.") if $repo_type ne 'git' && $repo_type ne 'svn';

                $default_source= $name unless $default_source;
                $sources{$name}= $path;

                get_repo_info($repo_type, $path);
                next;
            }
            if ($line =~ /^output_path\s+(.+)$/) {
                return 1 if $not_void_context->();
                next if $opt_outpath;
                return $err->("Output path '$1' is not a directory") unless -d $1;

                # TODO: Support ~/...
                $output_path= $1;
                next;
            }
            if ($line =~ /^token_threshold\s+(\d+)$/) {
                return 1 if $not_void_context->();
                return $err->("Valid threshold values are from 10 to 100") if $1 < 10 || $1 > 100;

                $token_threshold = $1 / 100;
                next;
            }

            # TODO: "filetypes c99 perl php html"

            # Section declaration context

            if ($line =~ /^section\s+([A-Za-z][A-Za-z0-9_]*)(?:\s+(.+))?$/) {
                $ftype= undef;
                $section= $1;
                next if $section eq 'OMIT' || $section eq 'OTHER';
                return $err->("Section already defined") if $sections{$section};

                $new_section->($section, $2 ? $2 : $1, 0);
                next;
            }
            if ($line =~ /^omit$/) {
                return 1 if $not_section_context->();

                $sections{$section}{omit}= 1;
                next;
            }
            if ($line =~ /^(includes|excludes)\s+(.+)$/) {
                return 1 if $not_section_context->();

                my $key= $1;

                $warn->("'excludes' not implemented yet") if $key eq 'exclude';

                my ($source, $path)= ($2 =~ /^((.*?):(.*))$/) ? ($2, $3) : ("", $2);
                return $err->("Unknown source '$source'") unless $source eq "" || $sources{$source};
                return $err->("Path must begin with '/' by convention") unless $path =~ /^\/(.*)/;

                push @{ $sections{$section}{$key} }, [ $source, $1 ];
                next;
            }

            # File type declaration context

            if ($line =~ /^filetype\s+([A-Za-z][A-Za-z0-9_]*)(?:\s+(.+))?$/) {
                $section= undef;
                $ftype= $1;
                next if $ftypes{$ftype};    # Known bug: title ignored

                $new_ftype->($ftype, $2 ? $2 : $1);
                next;
            }
            if ($line =~ /^keywords\s+(.+)$/) {
                return 1 if $not_ftype_context->();

                push @{ $ftypes{$ftype}{'keywords'} }, split(/\s+/, $1);
                next;
            }
            if ($line =~ /^keywords_from\s+(.+)$/) {
                return 1 if $not_ftype_context->();
                return $err->("Unknown filetype '$1'") unless $ftypes{$ftype};

                push @{ $ftypes{$ftype}{'keywords'} }, @{ $ftypes{$1}{'keywords'} };
                next;
            }
            if ($line =~ /^(files_re|tokens_exclude_re|tokens_include_re)\s+(.+)$/) {
                return 1 if $not_ftype_context->();

                $ftypes{$ftype}{$1}= $2;
                next;
            }

            return $err->("Syntax error");
        }
        return 0;
    };

    init();

    $new_section->('OMIT',  ' OMIT',  1, 1);
    $new_section->('OTHER', ' OTHER', 0, 1);

    my $result= $include->($file, $content);
    if ($result) {
        printnl("Can't read config file '$file'") if $result == 2;
        return 1;
    }

    unless ($project_name) {
        printnl("ERROR in $file:\n  A 'project' directive is missing. Please add a 'project <name> <title>' to your config file!");
        return 1;
    }

    unless ($default_source) {
        printnl("ERROR in $file:\n  A 'source' directive is missing. Please add a 'source <name> <path>' to your config file!");
        return 1;
    }

    $sections{'OTHER'}{'index'}= scalar @sections; 
    push @sections, 'OTHER', 'OMIT';

    for (keys %ftypes) {
        $ftypes{$_}{'keywords_re'}= join('|', @{ $ftypes{$_}{'keywords'} });
        delete $ftypes{$_}{'keywords'};  # Remove from memory
    }

    return 0;
}


###############################################################################
#
#       Collect Files
#
###############################################################################

# Implements an directory reader as Iterator
# Read "Higher Order Perl" by MJ Dominus
sub _dir_walk {
    my @queue = shift;
    my $want_dirs= shift || 0;
    return sub {
        while (@queue) {
            my $file = shift @queue;
            if (-d $file) {
                next if $file =~ /\/\.[^\/]+$/;  # Skip dot directories (.svn, .git, ...)

                opendir my $dh, $file or next;
                my @newfiles = grep { $_ ne "." && $_ ne ".." } readdir $dh;

                unshift @queue, map "$file/$_", @newfiles;

                ## Insert sorted, so that directories come first
                # unshift @queue, map "$file/$_", sort {
                #     -d "$file/$a"
                #         ? (-d "$file/$b" ? $a cmp $b : -1)
                #         : (-d "$file/$b" ? 1 : $a cmp $b)
                # } @newfiles;

                next unless $want_dirs;
            }
            return $file;
        }
    };
}

sub collect_files {

    printx("Collecting files: running...");

    my %filter;
    map { $filter{$_}= [] } keys %sources;

    # Collect path filters hashed by source
    for my $section (@sections) {
        my $includes= $sections{$section}{'includes'};
        for my $include (@$includes) {
            my $source= $include->[0] || $default_source;
            my $path= ($include->[1] eq '') ? '' : $include->[1] . '/';
            my $depth= $path =~ tr/\///;
            push @{ $filter{$source} }, [
                $section,                   # 0 section no
                $source,                    # 1 source, unused
                $path,                      # 2 path
                $depth,                     # 3 depth
                length($path)               # 4 length(path)
            ];
        }
    }

    my $must_analyze= sub {
        my $section= shift;
        my $reason= shift;

        $analyze_sections{$section}{$reason}++, return
            if defined $analyze_sections{$section}{$reason};
        $analyze_sections{$section}{$reason}= 1;
    };

    my $files_count= 0;

    # Collect files and assign them to the different sections
    for my $source (keys %filter) {
        my @filter= sort {
            $b->[3] <=> $a->[3] || $a->[2] cmp $b->[2]
        } @{ $filter{$source} };

        my $path= $sources{$source};
        my $it= _dir_walk($path);
        my $qm_path= quotemeta($path);
        my $path_re= qr/^$qm_path\/(.*)/;
        while (my $full_file= $it->()) {
            for my $ftype (keys %ftypes) {
                next unless $full_file =~ /$ftypes{$ftype}{'files_re'}/;

                $full_file =~ $path_re or die "Hmm. I found the file '$full_file' which doesn't start with '$path'. Giving up *sigh*...";
                my $file= $1;

                my $section= "OTHER";
                for my $filter (@filter) {
                    next unless substr($file, 0, $filter->[4]) eq $filter->[2];

                    $section= $filter->[0];
                    last;
                }
                next if $sections{$section}{'omit'};

                my $file_key= "$source:$file";
                my $file_no= $file_cache{"$file_key:id"};
                my $lines= -1;

                if (!defined $file_no) {
                    $file_no= int($file_cache{'.count'} || 0);
                    $file_cache{"$file_key:id"}= $file_no;
                    $file_cache{"$file_key:mtime"}= mtime($full_file);
                    $file_cache{'.count'}= $file_no + 1;

                    # New file, must re-analyze Section:
                    $must_analyze->($section, "new file(s)");
                }
                else {
                    my $mtime= mtime($full_file);
                    if ($mtime != ($file_cache{"$file_key:mtime"} || 0)) {
                        $file_cache{"$file_key:mtime"}= $mtime;

                        # Changed file, must re-analyze Section:
                        # Actually, we could only re-analyze the file, but then the tokens
                        # may be slightly wrong. Which, on the other hand, maybe doesn't really
                        # matter. I'll have to check this out some time...
                        $must_analyze->($section, "modified file(s)");
                    }
                    else {
                        $lines= $file_cache{"$file_key:lines"};
                        if (!defined $lines) {
                            $lines= -1;

                            # We need to know the number of lines in the file. If it's missing,
                            # we'll have to re-analyze:
                            $analyze_sections{$section}= 3;
                            $must_analyze->($section, "missing file length(s)");
                        }
                    }
                }

                push @{ $sections{$section}{'files'} }, {
                        ftype => $ftype,
                        source => $source,
                        file => $file,
                        file_no => int($file_no),
                        section => $section,
                        lines => $lines,
                        lines_per_part => lines_per_part($lines)
                    };
                $files_count++;
                last;
            }
        }
    }
    printx();

    my @new_sections= ();
    for my $section (@sections) {
        unless (@{ $sections{$section}{'files'} }) {
            printnl("Collecting files: Section '$section' omitted because it contains no files")
                unless $sections{$section}{'omit'} || $section eq 'OTHER';
            next;
        }
        $sections{$section}{'index'}= scalar @new_sections;
        push @new_sections, $section;
    }
    @sections= @new_sections;

    # Give 'OTHER' section a reasonable name if the user hasn't
    if (defined $sections{'OTHER'} && substr($sections{'OTHER'}{'title'}, 0, 1) eq ' ') {
        $sections{'OTHER'}{'title'}= scalar @sections == 1 ? "All files" : "Other files";
    }

    printnl("Collecting files: finished, found $files_count files");
}

sub lines_per_part {
    my $lines= shift;

    return 0 if $lines < 0;

    # If stuff is zipped, hand back bigger parts
    my $factor= $opt_zip ? 3 : 1;

    return $lines if $lines < 300 * $factor;

    $lines= ceil($lines / 15);
    return 200 * $factor if $lines < 200 * $factor;
    return 1500 * $factor if $lines > 1500 * $factor;
    return $lines;
}

###############################################################################
#
#       Analyze Files
#
###############################################################################

sub _analyze_file {
    my $section= shift;
    my $fileinfo= shift;

    my $ftype= $fileinfo->{'ftype'};
    my $source= $fileinfo->{'source'};
    my $file= $fileinfo->{'file'};
    my $file_no= $fileinfo->{'file_no'};

    printx("Analysing section '$section': reading file '$file'");

    my $tokens= $sections{$section}{'tokens'};

    my $full_file= $sources{$source} . '/' . $file;

    my $content= read_file($full_file);
    my $include_re= $ftypes{$ftype}{'tokens_include_re'};
    $include_re=  qr/\b($include_re)\b/; 

    my $exclude_re=  $ftypes{$ftype}{'tokens_exclude_re'};
    my $keywords_re= $ftypes{$ftype}{'keywords_re'};
    $exclude_re= $exclude_re ? ($keywords_re ? $exclude_re . '|' . $keywords_re : $exclude_re) : $keywords_re;
    $exclude_re= $exclude_re eq '' ? undef : qr/^($exclude_re)$/;

    my $line_no= 0;
    for my $line (split(/\n\r?/, $content)) {
        $line_no++;

        while ($line =~ /$include_re/g) {
            next if defined $exclude_re && $1 =~ $exclude_re;

            push @{ $tokens->{$1} }, "$file_no,$line_no";
        }
    }

    if ($fileinfo->{'lines'} < 0) {
        my $file_key= "$source:$file";
        $file_cache{"$file_key:lines"}= $fileinfo->{'lines'}= $line_no;
        $fileinfo->{'lines_per_part'}= lines_per_part($line_no);
    }
}

sub analyze_files {

    printx("Analysing sections: running...");

    for my $section (@sections) {

        if ($analyze_sections{$section}) {
            my @reasons= ();
            for my $key (sort keys %{ $analyze_sections{$section} }) {
                push @reasons, $analyze_sections{$section}{$key} . " $key";
            }
            printnl("Analysis forced: " . join(", ", @reasons));
            $build_sections{$section}= 2;
        }

        # Try to read cached tokens, if not forced by command line
        elsif (!defined $build_sections{$section}) {
            my $cached= read_file("cache/$project_name-$section.tokens");
            if ($cached) {
                my $tokens;
                eval $cached;
                $sections{$section}{'tokens'}= $tokens;
                next;
            }

            printnl("No data for section '$section'. Analysis forced!");
            $build_sections{$section}= 1;
        }

        for (@{ $sections{$section}{'files'} }) {
            _analyze_file($section, $_);
        }
        printnl("Analysing section '$section': finished");

        # Convert arrays to strings to greatly reduce memory consumption
        my $tokens= $sections{$section}{'tokens'};
        for (keys %$tokens) {
            $tokens->{$_}= join(':', @{ $tokens->{$_} });
        }

        my $dumper= Data::Dumper->new([ $tokens ], [ 'tokens' ]);
        $dumper->Indent(0);

        write_file("cache/$project_name-$section.tokens", $dumper->Dump());
    }
    printnl("Analysing sections: finished");
}


###############################################################################
#
#       Generate "data.js"
#
###############################################################################

sub _sections_as_js {
    return "var sections=[" . join(",\n", map {
        "['$_','" . $sections{$_}{'title'} . "']"
    } grep { $_ ne 'OMIT' } @sections) . "];\n";
}

sub _files_as_js {
    my $files= shift;

    return "var files=[" . join(",\n", map { $_
        ? "[" . $_->{'lines_per_part'}
            . "," . $_->{'lines'}
            . ",'" . $_->{'source'} . ':' . $_->{'file'} . "'"
            . "," . $sections{$_->{'section'}}{'index'}
            . "]"
        : 'null'
    } @$files) . "];\n";
}

# Remove tokens that appear too often. Use median to decide.
sub _cleanup_tokens {
    my $tokens= shift;

    printx("Cleaning tokens: running...");

    my %ref_count;
    my %median;
    my $token_count= 0;
    while (my ($token, $refs)= each %$tokens) {
        my $ref_count= ($refs =~ tr/://) + 1;
        $ref_count{$token}= $ref_count;
        $median{$ref_count}= 0;
        $token_count++;
    }
    my @median= sort { $a <=> $b } keys %median;
    return unless @median;

    # IDEA: optional lower limit: remove 2 occurances in same file

    my $max_ref_count= $median[$#median * ($token_threshold ** 1.5)];

    my $removed_count= 0;
    while (my ($token, $ref_count)= each %ref_count) {
        next if $ref_count >= 2 && $ref_count <= $max_ref_count;

        delete $tokens->{$token};
        $removed_count++;

        for my $section (@sections) {
            my $tokens= $sections{$section}{'tokens'};
            delete $tokens->{$token}
        }
    }
    printnl("Cleaning tokens: finished, removed $removed_count of $token_count tokens");
}

# This function is a bit difficult to read because some optimizations are done...
sub _tokens_as_js {
    my $tokens= shift;

    ## Safari doesn't like this optimisation:
    ## my $js_keywords_re= $ftypes{'javascript'}{'keywords_re'};
    ## $js_keywords_re= qr/^(?:$js_keywords_re)$/ if $js_keywords_re;
    ## my $needs_quotes_re= qr/[^A-Za-z0-9_]/;

    my @memoize_value;  # Using an array instead of a hash because it's faster
    my @chr;

    $chr[$_]= chr($_ + 32) for 0 .. 95;
    $chr[$_]= '~' . chr($_ + 31) for 7, 60, 94, 95;  # Some chars must be escaped: "'", "~", "\", chr(127). "~" because it's our escape char

    my $code= sub {
        my $is_file= shift;
        my $value= shift;

        my $value_key= $is_file + $value * 2;
        return $memoize_value[$value_key] if defined $memoize_value[$value_key];

        # Values are packed to sequences of chr(32)..chr(126).
        # The lower 1.5 bits of the last char holds this information:
        # 0: char in sequence, 1: last char in sequence, 2: last char in sequence and value is file_no

        # Modify the values so that the escaped chars keep away from the lower popular numbers.
        # Do that by xoring with 24 (any value will do, found by trial & error)
        # So, 7 becomes 31, 60 -> 36, 94 -> 70, 95 -> 71. Well, seems to work.

        my @result= $chr[(($value & 31) * 3 + ($is_file ? 2 : 1)) ^ 24];
        $value >>= 5;
        while ($value) {
            unshift @result, $chr[(($value & 31) * 3) ^ 24];
            $value >>= 5;
        }
        return $memoize_value[$value_key]= join('', @result);
    };

    my @xrefs;
    for my $token (sort keys %$tokens) {

        # Convert "1,2:3,4" to [ [1,2], [3,4] ]
        my @refs= sort { $a->[0] <=> $b->[0] || $a->[1] <=> $b->[1] }
                    map { [ split(/,/) ] }
                    split(/:/, $tokens->{$token});
        my @xref;
        my $last_file_no= 0;
        my $last_line_no= 0;

        for my $ref (@refs) {
            my ($file_no, $line_no)= ($ref->[0], $ref->[1]);
            if ($file_no != $last_file_no) {
                push @xref, $code->(1, $file_no - $last_file_no);
                $last_file_no= $file_no;
                $last_line_no= 0;
            }
            else {
                next if $line_no == $last_line_no;
            }

            # Inlined part of $code. Makes the whole function ~25% faster.
            my $value_key= ($line_no - $last_line_no) * 2;
            if (defined $memoize_value[$value_key]) {
                push @xref, $memoize_value[$value_key];
                $last_line_no= $line_no;
                next;
            }

            push @xref, $code->(0, $line_no - $last_line_no);
            $last_line_no= $line_no;
        }

        ## Safari doesn't like this:
        ## if (($js_keywords_re && $token =~ $js_keywords_re) || $token =~ $needs_quotes_re) {
        ##     $token= "'$token'";
        ## }

        push @xrefs, "'$token':'" . join('', @xref) . "'\n";
    }
    return "var tokens={" . join(',', @xrefs) . "};\n";
}

sub _array_as_js {
    my $result= "";
    $result .= ",'" . jsify($_) . "'" for @_;
    return '[' . substr($result, 1) . ']';
}

sub write_data_js {

    my @all_files;
    my %all_tokens;

    for my $section (@sections) {
        next if $sections{$section}{'omit'};

        my $files = $sections{$section}{'files'};
        for my $fileinfo (@$files) {
            $all_files[$fileinfo->{'file_no'}]= $fileinfo;
        }

        my $tokens = $sections{$section}{'tokens'};
        for my $token (keys %$tokens) {
            $all_tokens{$token}= defined $all_tokens{$token}
                                    ? $all_tokens{$token} . ':' . $tokens->{$token}
                                    : $tokens->{$token};
        }
    }

    _cleanup_tokens(\%all_tokens);

    printx("Writing 'data.js': running...");

    mkdir("$output_path/raxref-$project_name");

    my $content= "// Generated file. Changes useless\n"
        . "var files_path='raxref-$project_name';\n"
        . "var project_name='$project_name';\n"
        . "var project_title='" . jsify($project_title) . "';\n"
        . "var project_info=" . _array_as_js(@project_info) . ";\n"
        . _sections_as_js()
        . _files_as_js(\@all_files)
        . _tokens_as_js(\%all_tokens)
    ;

    write_file("$output_path/raxref-$project_name/data.js", $content, $opt_zip);

    printnl("Writing 'data.js': finished");
}


###############################################################################
#
#       Deploy required files
#
###############################################################################

sub deploy_requirements {

    my $copy= sub {
        my $target= shift;
        my $zip_it= shift;
        my @sources= @_;

        printx("Deploying requirements: $target");

        push @sources, $target unless scalar @sources;
        my $content= "";
        $target= "$output_path/$target";
        for (@sources) {
            my $source= "deploy/$_";
            return if mtime($source) <= mtime($target);
            $content .= read_file($source);
        }
        write_file($target, $content, $zip_it);
    };

    printx("Deploying requirements: running...");

    # Take into template and build main HTML file
    my $template= read_file("deploy/raxref-template.html") or die "Can't read 'deploy/raxref.html'";
    $template =~ s/\{\{PROJECT_FILES_PATH\}\}/raxref-$project_name/;
    write_file("$output_path/raxref-$project_name.html", $template, $opt_zip);

    # TODO: Make a link to index.html optional
    if (0 && !-e "$output_path/input.html") {
        eval { symlink("raxref-$project_name.html", "$output_path/index.html"); 1 };
    }
    $copy->(".htaccess");
    $copy->("raxref.js", $opt_zip);
    $copy->("raxref-all.css", $opt_zip);
    $copy->("raxref-requirements.js", $opt_zip,
        "jquery-1.3.2.min.js",
        "jquery.color-1.0.js",
        "jquery.scrollTo-1.4.0.min.js",
        "ui.core-r2397.js",
        "ui.draggable-r2397.js");
    printnl("Deploying requirements: finished");
}


###############################################################################
#
#       Generate Splitted HTML Files
#
###############################################################################

sub write_files {

    my %ftype_keywords_re;

    my $write_file= sub {
        my $section= shift;

        my $files = $sections{$section}{'files'};
        my $tokens = $sections{$section}{'tokens'};

        # Find all Tokens that contain word breaks. This happens with perl code (::).
        # Because the token lookup further on depends on tokens NOT containing
        # word breaks, this case must be treated specially.
        #
        # We build a RegEx that matches either these tokens or <\d+>. Later we will
        # temporarily replace the occurancies by <$counter++> and memorize all found
        # occurancies in @repl[$counter]. After were finished the replacements are undone.
        my @special_tokens;
        for (keys %$tokens) {
            push @special_tokens, quotemeta($_) if /\S\b\S/;
        }
        my $special_tokens= join('|', sort { length($b) <=> length($a) } @special_tokens);
        my $special_tokens_re= qr/\b(?:<\d+>|$special_tokens)/;
        my $special_tokens_temp_re1= qr/^<\d+>$/;
        my $special_tokens_temp_re2= qr/<(\d+)>/;

        my $file_i= 0;
        for my $fileinfo (@$files) {
            my ($ftype, $source, $file, $file_no, $lines, $lines_per_part)=
                        ($fileinfo->{'ftype'}, $fileinfo->{'source'},
                        $fileinfo->{'file'}, $fileinfo->{'file_no'},
                        $fileinfo->{'lines'}, $fileinfo->{'lines_per_part'});
            my $infile= $sources{$source} . '/' . $file;

            mkdir("$output_path/raxref-$project_name");

            my $extra;
            my @outfiles;
            for (my $l= 0; $l < $lines; ) {
                my $file= "$output_path/raxref-$project_name/file$file_no-" . ($l / $lines_per_part) .".html";
                my $from= $l;
                $l += $lines_per_part;
                $l= $lines if $l > $lines;
                push @outfiles, [ $file, $from, $l - 1 ];
                $extra= ' (missing)' unless -e $file;
            }

            unless ($extra) {
                next unless defined $build_sections{$section};

                $extra= ' (forced)';
            }

            printx("Writing files for section '$section': ", int(100 * ($file_i / scalar @$files)), "% done");
            # printx("Writing files for section '$section': ", int(1000 * ($file_i / scalar @$files)) / 10, "% done, current$extra file '", $infile, "'");

            my $code= read_file($infile);

            # Untabify (taken from MXR)
            # Support for vi's tab-width parameter:
            my $tabwidth= $code =~ /^#.*-[*]-.*?[ \t;]tab-width:[ \t]*([0-9]+).*-[*]-/m ? $1 : 8;

            # I hope the 'if' speeds things up. MXR does that. Maybe for a reason...
            if ($code =~ /\t/) {
                $code =~ s/^([^\t\n\r]*)\t/$1 . (' ' x ($tabwidth - (length($1) % $tabwidth)))/gem;
            }

            # Replace &, < and > because they have a meaning in HTML.
            # Use the numeric codes, 'gt', 'lt' or 'amp' may be keywords and would be replaced in the next step.
            $code =~ s/&/&#38;/g;
            $code =~ s/</&#60;/g;
            $code =~ s/>/&#62;/g;

            my $keywords_re= $ftypes{$ftype}{'keywords_re'};
            if ($keywords_re) {
                if (!defined $ftype_keywords_re{$ftype}) {
                    $ftype_keywords_re{$ftype}= qr/\b($keywords_re)\b/;
                }

                # Substitute keywords first, otherwise 'class' inside of <b>-tag will match.
                $code =~ s{$ftype_keywords_re{$ftype}}{<i>$1</i>}g;
            }

            # $code= "abc<17>def<8>ghij Digest::SHA1 klm<4>nopq";

            # Treat special tokens with RegEx
            my @repl;
            my $repl_count= -1;

            $code =~ s/$special_tokens_re/
                $repl[++$repl_count]= ($& =~ $special_tokens_temp_re1 ? $& : "<b class='_$&'>$&<\/b>");
                "<$repl_count>"
            /gex if scalar @special_tokens;

            # Faster than a RegEx:
            my @words= split(/\b/, $code);
            for (@words) {

                # Possible optimisation: check for keywords here in a similar manner
                # Probably needed for PHP. Didn't test yet...

                $_= "<b class='_$_'>$_</b>" if defined $tokens->{$_};
            }
            $code= join('', @words);

            # Undo special Tokens temporay replacement
            $code =~ s/$special_tokens_temp_re2/$repl[$1]/ge;

            my $pod_cmds= "(head1|head2|head3|head4|over|item|back|pod|begin|end|for|cut)";
            my @result;
            my $class= "";
            my $in_doc= 0;
            for (split(/\n\r?/, $code)) {

                # Finds "=podcmd" and "=<b class='_podcmd'>podcmd</b>"
                # Then wraps this inside "<span class='doc-cmd'> {found} </span>"
                if (/^=($pod_cmds\b|<b class='_$pod_cmds'>\3<\/b>)/) {

                    my $cmd= $2 || $3;
                    my $raw_cmd= $&;
                    my $rest= $';

                    # $_= "<span class='doc-cmd'>$&<\/span>" . $';

                    {
                        no warnings; # FIXME: How to avoid warnings if $2 is undef?
                        1 while $rest =~ s/([IBCLEFSXZ])&#60;(.*?)&#62;/\n1$1$2\n2/x;
                    }
                    $rest =~ s/\n1(.)/<span class='doc-markup'>$1&#60;<\/span>/g;
                    $rest =~ s/\n2/<span class='doc-markup'>&#62;<\/span>/g;

                    $_= "<span class='doc-cmd'>$raw_cmd<\/span>$rest";

                    # my $cmd= $2 || $3;

                    if ($cmd eq 'cut') {
                        $class= " class='doc doc-end'";
                        $in_doc= 0;
                    }
                    else {
                        $class= " class='doc doc-" . $cmd . ($in_doc ? "" : " doc-start") . "'";
                        $_= "<span class='doc-i'>$_</span>";
                        $in_doc= 1;
                    }
                }
                elsif ($in_doc) {
                    $class= " class='doc'";
                }
                else {
                    $class= "";
                }
                push @result, "<li$class>$_</li>";
            }

            # $code= "<!-- $source" . ":$file -->" . join("\n", @result);

            for my $out (@outfiles) {
                $code= "<!-- $source" . ":$file, lines " . ($out->[1] + 1) . ".." . ($out->[2] + 1) . " of $lines -->"
                    . join("\n", @result[$out->[1] .. $out->[2]]);
                write_file($out->[0], $code, $opt_zip);
            }

            $file_i++;
        }
        if ($file_i || defined $build_sections{$section}) {
            printnl("Writing files for section '$section': finished");
        }
    };

    for (@sections) {
        $write_file->($_) unless $sections{$_}{'omit'};
    }
    printnl("Writing files: finished");
}


###############################################################################
#
#       Main
#
###############################################################################

printnl("Raxref ", $VERSION, " by Dietrich Raisin\n");

if ($opt_source) {
    pod2usage(-verbose => 1) if $opt_conf;

    my $project_title= $opt_source;
    $project_title =~ s#.*\/##;
    $project_title ||= "Unamed";

    read_conf("", ""
        . "\nproject default $project_title"
        . "\ninclude conf/std.conf"
        . "\nsource default $opt_source"
    ) and exit 1;
}
else {
    read_conf($opt_conf || "raxref.conf") and (print("Try '$0 --help'\n"), exit 1);
}

$output_path= $opt_outpath || "output" unless $output_path;

unless (-d $output_path) {
    printnl("Output path '$output_path' is not a directory");
    exit 1;
}

printnl("Updating your project '$project_title'");

tie %file_cache, 'DB_File', "cache/$project_name-files.db";

if ($opt_all) {
    %file_cache= ();                       # Remove file cache
    $build_sections{$_}= 0 for @sections;  # Rebuild all
}

# Build lookup table
for (@ARGV) {
    unless (defined $sections{$_}) {
        print STDERR "There is no section named '$_' in '$opt_conf'!\n";
        print STDERR "Possible values are: '" . join("', '", @sections) . "'.\n";
        exit 1;
    }
    $build_sections{$_}= 0;
}

collect_files();
analyze_files();
write_data_js();
deploy_requirements();
write_files();

printnl("\nYour Raxref web application is now ready in '$output_path'!\n");

__END__

=head1 NAME

Raxref - Simple, lightweight and fast cross reference generator.

=head1 SYNOPSIS

B<raxref [--conf=file] [options] [section ...]>

B<raxref --source=path [options] [section ...]>

Use the first variant to use F<file> as conf file, or F<raxref.conf> as
default if omitted. Use the second variant to simply specify the source
path on the command line, auto-including F<conf/std.conf>.

=head1 EXAMPLES

B<raxref --source=~/parrot --outpath=/www/docs/parrot/html>

Raxref will scan the directory "~/parrot", grab everything it can find,
and output an interactive cross reference to "/www/docs/parrot/html".

B<raxref --conf raxref-parrot_rakudo.conf --outpath=/www/docs/parrot/html>

Raxref will read the configuration from "raxref-parrot_rakudo.conf", grab
everything it can find the paths described in it, and output an interactive
cross reference to "/www/docs/parrot/html".

=head1 OPTIONS

=over

=item --help (-h)

Output a brief help message.

=item --man (-m)

Output the man page. This is similar to C<perldoc raxref>

=item --conf=file (-c file)

Specify the config file. Defaults to F<raxref.conf> or to none if
C<--source> is specified.

=item --all (-a)

Rebuild all sections.

=item --outpath=path (-o path)

Specifiy the output path. Defaults to "output".
This overrides any given configuration directive "output_path".

=item --quiet (-q)

Omit console output.

=item --zip (-z)

Generate additional zipped output.
If you configure your web server accordingly, the files can be served much
more efficiently.

=back

=head1 DESCRIPTION

B<Raxref> takes a source tree and generates an interactive
web application consisting of a source browser and,
mostly important, a cross reference.

The default config file is F<raxref.conf>.

B<Raxref> doesn't need a configuration file but you probably want
one for big projects because you can specify different sections
and help B<raxref> to make the output more convenient.

To force a build of certain sections, add them to the command line, or
use the C<--all> switch to rebuild everything. C<--all> will also rebuild
all caches.

=head1 TRIVIA

It was originally written to understand the Parrot project,
but you may use it for any project, because it's
not Parrot-specific at all.

B<Raxref> is somewhat like MXR (Mozilla Cross Referencer) or
LXR (Linux Cross Referencer), but much simpler to use and
(I think) with a more user friendly output.

B<Raxref> tries to cache a lot, so it takes a little more
time on the first run, and then gets really fast.

The output of B<Raxref> was designed to be web browser friendly.
This means that instead of fetching huge files, most are broken into small
pieces. The browser also will fetch stuff in parallel. So hopefully your
patience won't be taxed. (Things could be even better by compressing the
output, but most web servers would have to be configured to support
that properly. So for now that's left out. Sorry, Mr. Souders)

There's also a bundled config file suitable for Parrot.

=head1 CONFIG FILES

The config files describe your project repository. Usually two lines
will be sufficient:

  include conf/std.conf
  source myproject /home/me/projects/myproject

This tells B<raxref> that you want to use the standard file type
definitions from 'std.conf', and where to find the sources of your
project.

Running B<raxref -c myproject.conf> will generate the web application
in the directory F<output>.

If you want to describe your project in more detail, these are the
directives that B<Raxref> will accept in conf files:

=over

=item C<project name title>

Tells B<Raxref> how you call your project. The project identifier
C<name> is used for file names and such, so keep it unique. The C<title>
will appear in the generated user interface.

=item C<info text>

TBD

=item C<zip>

Turn on generation of compressed output - suitable for being served from
a properly configured web server.

The output directory will contain a F<.htaccess> file for Apache that
turns on compression.

TBD

=item C<source name path [repo-type]>

This is where your source code lives. You can have multiple C<source>
directives. Parameters of the C<includes> and C<excludes> directives
must then be prefixed with the C<source> name followed by a colon, e.g.
C<includes inclsrc:/includes>.

The optional C<repo-type> may be C<git> or C<svn> and will only be used
to retrieve version information.

=item C<section name title>

Mainly a collection of parts of the source tree.

There are two special section names:

 C<OMIT>   Everything in this section will be omitted
 C<OTHER>  Everything that doesn't go in any other section will go in here

TBD

=item C<omit>

In C<section> context.

The section will be omitted in the output.

=item C<includes source-name:path>

In C<section> context.

C<source-name> is a source name (see C<source>).

C<path> is a relative path to the path specified by C<source-name>.

Example:

 source src ~/project/src

 section tools  Tools and Docs
 includes src:/tools
 excludes src:/tools/temp

=item C<excludes source:path>

In C<section> context.

See C<includes>.

TBD

=item C<output_path path>

Specifies the output path for the files C<Raxref> generates.

=item C<token_threshold value>

Rarely needed.
C<value> is a number from C<0.1> to C<1.0> (default is C<0.85>).
B<Raxref> removes tokens from the cross reference if they are to infrequent.
If you want more tokens, set C<token_threshold> to C<1.0>.
If you want less, specify a small value.

=item C<filetype name title>

You won't need that.

See F<conf/std.conf> for an example.

TBD

=item C<keywords keyword1 keyword2 ...>

You won't need that.

See F<conf/std.conf> for an example.

TBD

=item C<keywords_from filetype>

You won't need that.

See F<conf/std.conf> for an example.

TBD

=item C<file_re regex>

You won't need that.

See F<conf/std.conf> for an example.

TBD

=item C<tokens_exclude_re>

You won't need that.

See F<conf/parrot.conf> for an example.

TBD

=item C<tokens_include_re>

You won't need that.

See F<conf/parrot.conf> for an example.

TBD

=back

=head1 SHAMELESS PLUG

If you like this product, you may also like rabak (http://www.raisin.de/rabak),
a powerful, rsync based backup solution.

=cut
