#!/usr/bin/perl

# Raxref - Simple, lightweight and fast Cross Referencing

# Like MXR, LXR and LXRng, but with much more KISS

# Author: Dietrich Raisin, info1@raisin.de
# License: see LICENSE file

use warnings;
use strict;

use Getopt::Long 2.24 qw( :config auto_version bundling );
use Pod::Usage;
use File::Copy;
use DB_File;
use POSIX qw( ceil );

use Data::Dumper;

our $VERSION= '0.1';

# TODO: Doc
# my $have_zlib;

# Zlib not yet NOT IMPLEMENTED
# BEGIN {
#     eval { require Compress::Raw::Zlib; };
#     unless ($@) {
#         $have_zlib= 1;
#         import Compress::Raw::Zlib;
#     }
# }

our $opt_quiet;
our $opt_conf;
our $opt_source;
our $opt_all;
our $opt_outpath;
our $opt_help;
our $opt_man;

GetOptions( "quiet|q", "conf|c=s", "source|s=s", "all|a", "outpath|o=s", "help|h", "man|m" ) or pod2usage(2);
pod2usage(-verbose => 1) if $opt_help;
pod2usage(-verbose => 2) if $opt_man;

# TODO: Doc
my $project_name;
my $project_title;
my %ftypes;
my $output_path;
my $token_threshold;

# Contains: $sources[$source]= $path
my %sources;
my $default_source;

# Contains: See read_conf()
my %sections;
my @sections;

# Tied DB_File handles for caches
my %file_cache;

# List of sections to be built
my %build_sections;

# List of sections that must be re-analyzed because files changed
my %analyze_sections;

###############################################################################
#
#       TOOLS
#
###############################################################################

sub mtime {
    return (stat($_[0]))[9] || 0;
}

{
    my $last_text= '';

    sub printx {
        my $text= join('', @_);

        return if $opt_quiet;

        local $|= 1;
        print "\r", " " x length($last_text), "\r", $text;
        $last_text= $text;
    }

    sub printnl {
        my $text= join('', @_);

        return if $opt_quiet;

        printx();
        print "$text\n";
    }
}

# DEBUG: For checking memory consumption
# sub die2 {
#     print STDERR "OK!\n"; <STDIN>; die;
# }

# TODO: Implement some sort of warning if file can't be read
sub read_file {
    my $file= shift;
    local $/= undef;
    my $fin;
    open $fin, $file or return "";
    my $result= <$fin>;
    close $fin;
    return $result;
}

sub write_file {
    my $file= shift;
    my $content= shift;

    my $fout;
    open $fout, ">$file" or die "Can't write '$file'";
    print $fout $content;
    close $fout;
}


###############################################################################
#
#       Read Configuration
#
###############################################################################

sub init {

    # Reset all data
    $project_name= undef;
    $project_title= undef;
    %ftypes= ();
    $output_path= $opt_outpath;
    %sources= ();
    $default_source= undef;
    %sections= ();
    @sections= ();
    %build_sections= ();
    %analyze_sections= ();
    $token_threshold= 0.85;        # 0.1 .. 1
}    

sub read_conf {
    my $file= shift;
    my $content= shift;

    # Config files to include
    my %files= ($file => 0);

    my $new_section= sub {
        $sections{$_[0]}= {
            title => $_[1],
            omit => $_[2],
            includes => [],
            # TODO: Implement: excludes => [],
            files => [],
            tokens => {},
            index => scalar @sections,
        };
        push @sections, $_[0] unless defined $_[3];
    };

    my $new_ftype= sub {
        $ftypes{$_[0]}= {
            title => $_[1],
            files_re => '\/\/$',   # Never matches
            keywords => [],
            tokens_include_re  => '[a-zA-Z][a-zA-Z0-9_]+',
            tokens_exclude_re  => undef,
        };
    };

    my $include;             # "my $sub= sub { $sub->() }" doesn't work in perl 5
    $include= sub {
        my $file= shift;
        my $content= shift;

        $files{$file}= 1;    # mark as included

        my $section;
        my $ftype;
        my $line_i= 0;
        my $line;

        my $err= sub {
            my $message= shift;

            # TODO: Do something saner than exiting, perhaps...
            printnl("ERROR in '$file', line $line_i:\n  $message!\n  The current line is '$line'");
            return 1;
        };

        my $warn= sub {
            my $message= shift;
            printnl("WARNING in '$file', line $line_i:\n  $message!\n The current line is '$line'");
        };

        my $not_void_context= sub {
            return $err->("Not valid inside 'section' declaration") if $section;
            return $err->("Not valid inside 'filetype' declaration") if $ftype;
            return 0;
        };

        my $not_section_context= sub {
            return $err->("'section' declaration missing") unless $section;
            return $err->("Not valid inside 'filetype' declaration") if $ftype;
            return 0;
        };

        my $not_ftype_context= sub {
            return $err->("'filetype' declaration missing") unless $ftype;
            return $err->("Not valid inside 'section' declaration") if $section;
            return 0;
        };

        $content= read_file($file) if $file;
        return 2 if $content eq "";

        for (split(/\n\r?/, $content)) {
            $line= $_;
            $line_i++;

            # Kill trailing white space and comments. Comments must start at beginning of line
            # or have one white space before '#' to enable '#' in values.
            $line =~ s/\s+(?:#.*)?$//;
            next if $line eq '' || $line =~ /^#/;

            # Any context

            if ($line =~ /^include\s+(.*)$/) {
                $warn->("File '$1' already included. Ignored."), next if $files{$1};

                return $err->("Error in included file") if $include->($1);
                next;
            }

            # Void context

            if ($line =~ /^project\s+([A-Za-z][A-Za-z0-9_]*)\s+(.+)$/) {
                return 1 if $not_void_context->();
                return $err->("Only one 'project' directive allowed. This is the second") if $project_name;

                $project_name= $1;
                $project_title= $2;
                next;
            }
            if ($line =~ /^source\s+([A-Za-z][A-Za-z0-9_]*)\s+(.+)$/) {
                return 1 if $not_void_context->();
                return $err->("Source already defined") if $sources{$1};
                return $err->("Source path '$2' is not a directory") unless -d $2;

                $default_source= $1 unless $default_source;
                $sources{$1}= $2;
                next;
            }
            if ($line =~ /^output_path\s+(.+)$/) {
                return 1 if $not_void_context->();
                next if $opt_outpath;
                return $err->("Output path '$1' is not a directory") unless -d $1;

                $output_path= $1;
                next;
            }
            if ($line =~ /^token_threshold\s+(\d+)$/) {
                return 1 if $not_void_context->();
                return $err->("Valid threshold values are from 10 to 100") if $1 < 10 || $1 > 100;

                $token_threshold = $1 / 100;
                next;
            }

            # TODO: "filetypes c99 perl php html"

            # Section declaration context

            if ($line =~ /^section\s+([A-Za-z][A-Za-z0-9_]*)(?:\s+(.+))?$/) {
                $ftype= undef;
                $section= $1;
                next if $section eq 'OMIT' || $section eq 'OTHER';
                return $err->("Project already defined") if $sections{$section};

                $new_section->($section, $2 ? $2 : $1, 0);
                next;
            }
            if ($line =~ /^omit$/) {
                return 1 if $not_section_context->();

                printnl("$file, line $line_i: WARNING! 'omit' not implemented yet!");

                $sections{$section}{omit}= 1;
                next;
            }
            if ($line =~ /^(includes|excludes)\s+(.+)$/) {
                return 1 if $not_section_context->();

                my $key= $1;

                printnl("$file, line $line_i: WARNING! 'excludes' not implemented yet!") if $key eq 'exclude';

                my ($source, $path)= ($2 =~ /^((.*?):(.*))$/) ? ($2, $3) : ("", $2);
                return $err->("Unknown source '$source'") unless $source eq "" || $sources{$source};
                return $err->("Path must begin with '/' by convention") unless $path =~ /^\/(.*)/;

                push @{ $sections{$section}{$key} }, [ $source, $1 ];
                next;
            }

            # File type declaration context

            if ($line =~ /^filetype\s+([A-Za-z][A-Za-z0-9_]*)(?:\s+(.+))?$/) {
                $section= undef;
                $ftype= $1;
                next if $ftypes{$ftype};    # Known bug: title ignored

                $new_ftype->($ftype, $2 ? $2 : $1);
                next;
            }
            if ($line =~ /^keywords\s+(.+)$/) {
                return 1 if $not_ftype_context->();

                push @{ $ftypes{$ftype}{'keywords'} }, split(/\s+/, $1);
                next;
            }
            if ($line =~ /^keywords_from\s+(.+)$/) {
                return 1 if $not_ftype_context->();
                return $err->("Unknown filetype '$1'") unless $ftypes{$ftype};

                push @{ $ftypes{$ftype}{'keywords'} }, @{ $ftypes{$1}{'keywords'} };
                next;
            }
            if ($line =~ /^(files_re|tokens_exclude_re|tokens_include_re)\s+(.+)$/) {
                return 1 if $not_ftype_context->();

                $ftypes{$ftype}{$1}= $2;
                next;
            }

            return $err->("Syntax error");
        }
        return 0;
    };

    init();

    $new_section->('OMIT',   'Omitted paths', 1, 1);
    $new_section->('OTHER',  'Other',         0, 1);

    my $result= $include->($file, $content);
    if ($result) {
        printnl("Can't read config file '$file'") if $result == 2;
        return 1;
    }

    unless ($project_name) {
        printnl("ERROR in $file:\n  A 'project' directive is missing. Please add a 'project <name> <title>' to your config file!");
        return 1;
    }

    unless ($default_source) {
        printnl("ERROR in $file:\n  A 'source' directive is missing. Please add a 'source <name> <path>' to your config file!");
        return 1;
    }

    $sections{'OTHER'}{'index'}= scalar @sections; 
    push @sections, 'OTHER', 'OMIT';

    for (keys %ftypes) {
        $ftypes{$_}{'keywords_re'}= join('|', @{ $ftypes{$_}{'keywords'} });
        delete $ftypes{$_}{'keywords'};  # Remove from memory
    }

    return 0;
}


###############################################################################
#
#       Collect Files
#
###############################################################################

# Implements an directory reader as Iterator
# Read "Higher Order Perl" by MJ Dominus
sub _dir_walk {
    my @queue = shift;
    my $want_dirs= shift || 0;
    return sub {
	while (@queue) {
            my $file = shift @queue;
	    if (-d $file) {
		next if $file =~ /\/\.[^\/]+$/;  # Skip dot directories (.svn, .git, ...)

		opendir my $dh, $file or next;
		my @newfiles = grep { $_ ne "." && $_ ne ".." } readdir $dh;

                # Insert sorted, so that directories come first
		unshift @queue, map "$file/$_", sort {
                    -d "$file/$a"
                        ? (-d "$file/$b" ? $a cmp $b : -1)
                        : (-d "$file/$b" ? 1 : $a cmp $b)
                } @newfiles;
                next unless $want_dirs;
	    }
            return $file;
	}
    };
}

sub collect_files {

    printx("Collecting files: running...");

    my %filter;
    map { $filter{$_}= [] } keys %sources;

    # Collect path filters hashed by source
    for my $section (@sections) {
        my $includes= $sections{$section}{'includes'};
        for my $include (@$includes) {
            my $source= $include->[0] || $default_source;
            my $path= ($include->[1] eq '') ? '' : $include->[1] . '/';
            my $depth= $path =~ tr/\///;
            push @{ $filter{$source} }, [
                $section,                   # 0
                $source,                    # 1 source, unused
                $path,                      # 2 path
                $depth,                     # 3 depth
                length($path)               # 4 length(path)
            ];
        }
    }

    my $files_count= 0;

    # Collect files and assign them to the different sections
    for my $source (keys %filter) {
        my @filter= sort {
            $b->[3] <=> $a->[3] || $a->[2] cmp $b->[2]
        } @{ $filter{$source} };

        my $path= $sources{$source};
        my $it= _dir_walk($path);
        my $qm_path= quotemeta($path);
        my $path_re= qr/^$qm_path\/(.*)/;
        while (my $full_file= $it->()) {
            for my $ftype (keys %ftypes) {
                next unless $full_file =~ /$ftypes{$ftype}{'files_re'}/;

                $full_file =~ $path_re or die "Hmm. I found the file '$full_file' which doesn't start with '$path'. Giving up *sigh*...";
                my $file= $1;

                my $section= "OTHER";
                for my $filter (@filter) {
                    next unless substr($file, 0, $filter->[4]) eq $filter->[2];

                    $section= $filter->[0];
                    last;
                }
                next if $section eq 'OMIT';

                my $file_key= "$source:$file";
                my $file_no= int($file_cache{"$file_key:id"} || 0);
    
                if (!$file_no) {
                    $file_no= int($file_cache{'.count'} || 0);
                    $file_cache{"$file_key:id"}= $file_no;
                    $file_cache{'.count'}= $file_no + 1;

                    # New file, must re-analyze Project:
                    $analyze_sections{$section}= 1;
                }

                my $mtime= mtime($full_file);
                if ($mtime != ($file_cache{"$file_key:mtime"} || 0)) {
                    $file_cache{"$file_key:mtime"}= $mtime;

                    # Changed file, must re-analyze Project:
                    # Actually, we could only re-analyze the file, but then the tokens
                    # may be slightly wrong. Which, on the other hand, maybe doesn't really
                    # matter. I'll have to check this out some time...
                    $analyze_sections{$section}= 2;
                }

                my $lines= $file_cache{"$file_key:lines"};
                if (!defined $lines) {
                    $lines= -1;

                    # We need to know the number of lines in the file. If it's missing,
                    # we'll have to re-analyze:
                    $analyze_sections{$section}= 3;
                }

                # push @{ $sections{$section}{'files'} }, [ $ftype, $source, $file, $file_no, $section ];
                push @{ $sections{$section}{'files'} }, {
                        ftype => $ftype,
                        source => $source,
                        file => $file,
                        file_no => $file_no,
                        section => $section,
                        lines => $lines,
                        lines_per_part => lines_per_part($lines)
                    };
                $files_count++;
	        last;
            }
        }
    }
    printx();

    my @new_sections= ();
    for my $section (@sections) {
        unless (@{ $sections{$section}{'files'} }) {
            printnl("Collecting files: Section '$section' omitted because it contains no files")
                unless $section eq 'OMIT' || $section eq 'OTHER';
            next;
        }
        push @new_sections, $section;
    }
    @sections= @new_sections;

    printnl("Collecting files: finished, found $files_count files");
}

sub lines_per_part {
    my $lines= shift;
    
    return 0 if $lines < 0;
    return $lines if $lines < 300;

    $lines= ceil($lines / 15);
    return 200 if $lines < 200;
    return 1500 if $lines > 1500;
    return $lines;
}

###############################################################################
#
#       Analyze Files
#
###############################################################################

sub _analyze_file {
    my $section= shift;
    my $fileinfo= shift;

    my $ftype= $fileinfo->{'ftype'};
    my $source= $fileinfo->{'source'};
    my $file= $fileinfo->{'file'};
    my $file_no= $fileinfo->{'file_no'};

    printx("Analysing section '$section': reading file '$file'");

    my $tokens= $sections{$section}{'tokens'};

    my $full_file= $sources{$source} . '/' . $file;

    my $content= read_file($full_file);
    my $include_re= $ftypes{$ftype}{'tokens_include_re'};
    $include_re=  qr/\b($include_re)\b/; 

    my $exclude_re=  $ftypes{$ftype}{'tokens_exclude_re'};
    my $keywords_re= $ftypes{$ftype}{'keywords_re'};
    $exclude_re= $exclude_re ? ($keywords_re ? $exclude_re . '|' . $keywords_re : $exclude_re) : $keywords_re;
    $exclude_re= $exclude_re eq '' ? undef : qr/^($exclude_re)$/;
    
    my $line_no= 0;
    for my $line (split(/\n\r?/, $content)) {
	$line_no++;

        while ($line =~ /$include_re/g) {
            next if defined $exclude_re && $1 =~ $exclude_re;

            push @{ $tokens->{$1} }, "$file_no,$line_no";
        }
    }

    if ($fileinfo->{'lines'} < 0) {
        my $file_key= "$source:$file";
        $file_cache{"$file_key:lines"}= $fileinfo->{'lines'}= $line_no;
        $fileinfo->{'lines_per_part'}= lines_per_part($line_no);
    }
}

sub analyze_files {

    printx("Analysing sections: running...");

    for my $section (@sections) {

        if ($analyze_sections{$section}) {
            printnl("New or modified files. Analysis forced!");
            $build_sections{$section}= 2;
        }

        # Try to read cached tokens, if not forced by command line
        elsif (!defined $build_sections{$section}) {
            my $cached= read_file("cache/$project_name-$section.tokens");
            if ($cached) {
                my $tokens;
                eval $cached;
                $sections{$section}{'tokens'}= $tokens;
                next;
            }

            printnl("No data for section '$section'. Analysis forced!");
            $build_sections{$section}= 1;
        }

        for (@{ $sections{$section}{'files'} }) {
            _analyze_file($section, $_);
        }
        printnl("Analysing section '$section': finished");

        # Convert arrays to strings to greatly reduce memory consumption
        my $tokens= $sections{$section}{'tokens'};
        for (keys %$tokens) {
            $tokens->{$_}= join(':', @{ $tokens->{$_} });
        }

        my $dumper= Data::Dumper->new([ $tokens ], [ 'tokens' ]);
        $dumper->Indent(0);

        write_file("cache/$project_name-$section.tokens", $dumper->Dump());
    }
    printnl("Analysing sections: finished");
}


###############################################################################
#
#       Generate "data.js"
#
###############################################################################

sub _sections_as_js {
    return "var sections=[" . join(",\n", map {
        "['$_','" . $sections{$_}{'title'} . "']"
    } grep { $_ ne 'OMIT' } @sections) . "];\n";
}

sub _files_as_js {
    my $files= shift;

    return "var files=[" . join(",\n", map {
        $_ ? "[" . $_->{'lines_per_part'} . "," . $_->{'lines'} . ",'" . $_->{'file'} . "'," . $sections{$_->{'section'}}{'index'} . "]" : 'null'
    } @$files) . "];\n";
}

# Remove tokens that appear too often. Use median to decide.
sub _cleanup_tokens {
    my $tokens= shift;

    printx("Cleaning tokens: running...");

    my %ref_count;
    my %median;
    my $token_count= 0;
    while (my ($token, $refs)= each %$tokens) {
        my $ref_count= ($refs =~ tr/://) + 1;
        $ref_count{$token}= $ref_count;
        $median{$ref_count}= 0;
        $token_count++;
    }
    my @median= sort { $a <=> $b } keys %median;
    return unless @median;

    # IDEA: optional lower limit: remove 2 occurances in same file

    my $max_ref_count= $median[$#median * ($token_threshold ** 1.5)];

    my $removed_count= 0;
    while (my ($token, $ref_count)= each %ref_count) {
        next if $ref_count >= 2 && $ref_count <= $max_ref_count;

	delete $tokens->{$token};
        $removed_count++;

        for my $section (@sections) {
            my $tokens= $sections{$section}{'tokens'};
            delete $tokens->{$token}
        }
    }
    printnl("Cleaning tokens: finished, removed $removed_count of $token_count tokens");
}

# This function is a bit difficult to read because some optimizations are done...
sub _tokens_as_js {
    my $tokens= shift;

    ## Safari doesn't like this optimisation:
    ## my $js_keywords_re= $ftypes{'javascript'}{'keywords_re'};
    ## $js_keywords_re= qr/^(?:$js_keywords_re)$/ if $js_keywords_re;
    ## my $needs_quotes_re= qr/[^A-Za-z0-9_]/;

    my @memoize_value;  # Using an array instead of a hash because it's faster
    my @chr;
    
    $chr[$_]= chr($_ + 32) for 0 .. 95;
    $chr[$_]= '~' . chr($_ + 31) for 7, 60, 94, 95;  # Some chars must be escaped: "'", "~", "\", chr(127). "~" because it's our escape char

    my $code= sub {
        my $is_file= shift;
        my $value= shift;

        my $value_key= $is_file + $value * 2;
        return $memoize_value[$value_key] if defined $memoize_value[$value_key];

        # Values are packed to sequences of chr(32)..chr(126).
        # The lower 1.5 bits of the last char holds this information:
        # 0: char in sequence, 1: last char in sequence, 2: last char in sequence and value is file_no

        # Modify the values so that the escaped chars keep away from the lower popular numbers.
        # Do that by xoring with 24 (any value will do, found by trial & error)
        # So, 7 becomes 31, 60 -> 36, 94 -> 70, 95 -> 71. Well, seems to work.

        my @result= $chr[(($value & 31) * 3 + ($is_file ? 2 : 1)) ^ 24];
        $value >>= 5;
        while ($value) {
            unshift @result, $chr[(($value & 31) * 3) ^ 24];
            $value >>= 5;
        }
        return $memoize_value[$value_key]= join('', @result);
    };

    my @xrefs;
    for my $token (sort keys %$tokens) {

        # Convert "1,2:3,4" to [ [1,2], [3,4] ]
	my @refs= sort { $a->[0] <=> $b->[0] || $a->[1] <=> $b->[1] }
                    map { [ split(/,/) ] }
                    split(/:/, $tokens->{$token});
	my @xref;
	my $last_file_no= 0;
	my $last_line_no= 0;

	for my $ref (@refs) {
	    my ($file_no, $line_no)= ($ref->[0], $ref->[1]);
	    if ($file_no != $last_file_no) {
		push @xref, $code->(1, $file_no - $last_file_no);
		$last_file_no= $file_no;
	        $last_line_no= 0;
	    }
            else {
                next if $line_no == $last_line_no;
            }

            # Inlined part of $code. Makes the whole function ~25% faster.
            my $value_key= ($line_no - $last_line_no) * 2;
            if (defined $memoize_value[$value_key]) {
	        push @xref, $memoize_value[$value_key];
                $last_line_no= $line_no;
                next;
            }

	    push @xref, $code->(0, $line_no - $last_line_no);
            $last_line_no= $line_no;
	}

        ## Safari doesn't like this:
        ## if (($js_keywords_re && $token =~ $js_keywords_re) || $token =~ $needs_quotes_re) {
        ##     $token= "'$token'";
        ## }

	push @xrefs, "'$token':'" . join('', @xref) . "'\n";
    }
    return "var tokens={" . join(',', @xrefs) . "};\n";
}

sub _tokens_as_js__old {
    my $tokens= shift;

    my @xrefs;
    for my $token (sort keys %$tokens) {
	my @refs= split(/:/, $tokens->{$token});
	my @xref;
	my $last_file_no= 0;
	my $last_line_no= 0;
        
	for my $ref (@refs) {
	    my ($file_no, $line_no)= split(/,/, $ref);
	    if ($file_no != $last_file_no) {
		push @xref, 'f' . ($file_no - $last_file_no);
		$last_file_no= $file_no;
	        $last_line_no= 0;
	    }
            else {
                next if $line_no == $last_line_no;
            }
	    push @xref, ($line_no - $last_line_no);
	    $last_line_no= $line_no;
	}

	push @xrefs, "'$token':'" . join(',', @xref) . "'\n";
    }
    return "var tokens={" . join(',', @xrefs) . "};\n";
}

sub write_data_js {

    my @all_files;
    my %all_tokens;

    for my $section (@sections) {
        next if $section eq 'OMIT';

        my $files = $sections{$section}{'files'};
        for my $fileinfo (@$files) {
            $all_files[$fileinfo->{'file_no'}]= $fileinfo;
        }

        my $tokens = $sections{$section}{'tokens'};
        for my $token (keys %$tokens) {
            $all_tokens{$token}= defined $all_tokens{$token}
                                    ? $all_tokens{$token} . ':' . $tokens->{$token}
                                    : $tokens->{$token};
        }
    }

    _cleanup_tokens(\%all_tokens);

    printx("Writing 'data.js': running...");

    mkdir("$output_path/raxref-$project_name");

    my $fout;
    open $fout, ">$output_path/raxref-$project_name/data.js" or die "Can't write '$output_path/raxref-$project_name/data.js'";
    print $fout "// Generated file. Changes useless\n";
    print $fout "var files_path='raxref-$project_name';\n";
    print $fout "var project_name='$project_name';\n";
    (my $prtitle_html= $project_title) =~ s/'/\\'/g;
    print $fout "var project_title='$prtitle_html';\n";
    print $fout _sections_as_js();
    print $fout _files_as_js(\@all_files);
    print $fout _tokens_as_js(\%all_tokens);
    close $fout;

    printnl("Writing 'data.js': finished");
}


###############################################################################
#
#       Deploy required files
#
###############################################################################

sub deploy_requirements {

    my $copy= sub {
        my $source= shift;
        my $target= shift || $source;

        $source= "deploy/$source";
        $target= "$output_path/$target";
        return if mtime($source) <= mtime($target);
        
        printx("Deploying requirements: $source -> $target");
        copy($source, $target);
    };

    printx("Deploying requirements: running...");

    # Take into template and build main HTML file
    my $template= read_file("deploy/raxref-template.html") or die "Can't read 'deploy/raxref.html'";
    $template =~ s/\{\{PROJECT_FILES_PATH\}\}/raxref-$project_name/;
    write_file("$output_path/raxref-$project_name.html", $template);

    # TODO: Make a link to index.html optional
    if (0 && !-e "$output_path/input.html") {
        eval { symlink("raxref-$project_name.html", "$output_path/index.html"); 1 };
    }
    $copy->("raxref.js");
    $copy->("raxref-all.css");
    $copy->("jquery-1.3.2.min.js", "jquery.js");
    $copy->("jquery.color-1.0.js", "jquery.color.js");
    $copy->("jquery.scrollTo-1.4.0.min.js", "jquery.scrollTo.js");
    $copy->("ui.core-r2397.js", "ui.core.js");
    $copy->("ui.draggable-r2397.js", "ui.draggable.js");
    printnl("Deploying requirements: finished");
}


###############################################################################
#
#       Generate Splitted HTML Files
#
###############################################################################

sub write_files {

    my %ftype_keywords_re;

    my $write_file= sub {
        my $section= shift;
    
        my $files = $sections{$section}{'files'};
        my $tokens = $sections{$section}{'tokens'};

        # Find all Tokens that contain word breaks. This happens with perl code (::).
        # Because the token loopup further on depends on tokens NOT containing
        # word breaks, this case must be treated specially.
        #
        # We build a RegEx that matches either these tokens or <\d+>. Later we will
        # temporarily replace the occurancies by <$counter++> and memorize all found
        # occurancies in @repl[$counter]. After were finished the replacements are undone.
        my @special_tokens;
        for (keys %$tokens) {
            push @special_tokens, quotemeta($_) if /\S\b\S/;
        }
        my $special_tokens= join('|', @special_tokens);
        my $special_tokens_re= qr/\b(?:<\d+>|$special_tokens)/;
        my $special_tokens_temp_re1= qr/^<\d+>$/;
        my $special_tokens_temp_re2= qr/<(\d+)>/;

        my $file_i= 0;
        for my $fileinfo (@$files) {
            my ($ftype, $source, $file, $file_no, $lines, $lines_per_part)=
                        ($fileinfo->{'ftype'}, $fileinfo->{'source'},
                        $fileinfo->{'file'}, $fileinfo->{'file_no'},
                        $fileinfo->{'lines'}, $fileinfo->{'lines_per_part'});
            my $infile= $sources{$source} . '/' . $file;
            
            mkdir("$output_path/raxref-$project_name");

            my $extra;
            my @outfiles;
            for (my $l= 0; $l < $lines; ) {
                my $file= "$output_path/raxref-$project_name/file$file_no-" . ($l / $lines_per_part) .".html";
                my $from= $l;
                $l += $lines_per_part;
                $l= $lines if $l > $lines;
                push @outfiles, [ $file, $from, $l - 1 ];
                $extra= ' (missing)' unless -e $file;
            }

            unless ($extra) {
                next unless defined $build_sections{$section};

                $extra= ' (forced)';
            }
            
            printx("Writing files for section '$section': ", int(1000 * ($file_i / scalar @$files)) / 10, "% done, current$extra file '", $infile, "'");

            my $code= read_file($infile);

            # Replace &, < and > because they have a meaning in HTML.
            # Use the numeric codes, 'gt', 'lt' or 'amp' may be keywords and would be replaced in the next step.
            $code =~ s/&/&#38;/g;
            $code =~ s/</&#60;/g;
            $code =~ s/>/&#62;/g;

            my $keywords_re= $ftypes{$ftype}{'keywords_re'};
            if ($keywords_re) {
                if (!defined $ftype_keywords_re{$ftype}) {
                    $ftype_keywords_re{$ftype}= qr/\b($keywords_re)\b/;
                }

                # Substitute keywords first, otherwise 'class' inside of <b>-tag will match.
                $code =~ s{$ftype_keywords_re{$ftype}}{<i>$1</i>}g;
            }

            # $code= "abc<17>def<8>ghij Digest::SHA1 klm<4>nopq";

            # Treat special tokens with RegEx
            my @repl;
            my $repl_count= -1;

            $code =~ s/$special_tokens_re/
                $repl[++$repl_count]= ($& =~ $special_tokens_temp_re1 ? $& : "<b class='_$&'>$&<\/b>");
                "<$repl_count>"
            /gex if @special_tokens;

            # Faster than a RegEx:
            my @words= split(/\b/, $code);
            for (@words) {

                # Possible optimisation: check for keywords here in a similar manner
                # Probably needed for PHP. Didn't test yet...

                $_= "<b class='_$_'>$_</b>", next if defined $tokens->{$_};
            }
            $code= join('', @words);

            # Undo special Tokens temporay replacement
            $code =~ s/$special_tokens_temp_re2/$repl[$1]/ge;

            my $pod_cmds= "(head1|head2|head3|head4|over|item|back|pod|begin|end|for)";
            my @result;
            my $class= "";
            my $in_doc= 0;
            for (split(/\n/, $code)) {
                if (/^=(?:$pod_cmds\b|<b class='_$pod_cmds')/) {
                    $class= " class='doc doc-" . ($1 || $2) . ($in_doc ? "" : " doc-start") . "'";
                    $_= "<span class='doc-i'>$_</span>";
                    $in_doc= 1;
                }
                elsif (/^=(?:cut\b|<b class='_cut')/) {
                    $class= " class='doc doc-end'";
                    $in_doc= 0;
                }
                elsif ($in_doc) {
                    $class= " class='doc'";
                }
                else {
                    $class= "";
                }
                push @result, "<li$class>$_</li>";
            }

            # $code= "<!-- $source" . ":$file -->" . join("\n", @result);

            for my $out (@outfiles) {
                $code= "<!-- $source" . ":$file, lines " . ($out->[1] + 1) . ".." . ($out->[2] + 1) . " of $lines -->"
                    . join("\n", @result[$out->[1] .. $out->[2]]);
                write_file($out->[0], $code);
            }

            $file_i++;
        }
        if ($file_i || defined $build_sections{$section}) {
            printnl("Writing files for section '$section': finished");
        }
    };

    for (@sections) {
        $write_file->($_) unless $_ eq 'OMIT';
    }
    printnl("Writing files: finished");
}


###############################################################################
#
#       Main
#
###############################################################################

printnl("Raxref ", $VERSION, " by Dietrich Raisin\n");

if ($opt_source) {
    pod2usage(-verbose => 1) if $opt_conf;

    my $project_title= $opt_source;
    $project_title =~ s#.*\/##;
    $project_title ||= "Unamed";

    read_conf("", ""
        . "\nproject default $project_title"
        . "\ninclude conf/std.conf"
        . "\nsource default $opt_source"
    ) and exit 1;
}
else {
    read_conf($opt_conf || "raxref.conf") and exit 1;
}

$output_path= $opt_outpath || "output" unless $output_path;

unless (-d $output_path) {
    printnl("Output path '$output_path' is not a directory");
    exit 1;
}

printnl("Updating your project '$project_title'");

tie %file_cache, 'DB_File', "cache/$project_name-files.db";

if ($opt_all) {
    %file_cache= ();                       # Remove file cache
    $build_sections{$_}= 0 for @sections;  # Rebuild all
}

# Build lookup table
for (@ARGV) {
    unless (defined $sections{$_}) {
        print STDERR "There is no section named '$_' in '$opt_conf'!\n";
        print STDERR "Possible values are: '" . join("', '", @sections) . "'.\n";
        exit 1;
    }
    $build_sections{$_}= 0;
}

collect_files();
analyze_files();
write_data_js();
deploy_requirements();
write_files();

printnl("\nYour Raxref web application is now ready in '$output_path'!\n");

__END__

=head1 NAME

Raxref - Simple, lightweight and fast Cross Referencing
        
=head1 SYNOPSIS

raxref [--conf=file] [options] [section ...]

raxref --source=path [options] [section ...]

Use the first variant to use F<file> as conf file, or F<raxref.conf> as
default if omitted. Use the second variant to simply specify the source
path on the command line, auto-including F<conf/std.conf>.

 Options:
    --help (-h)              brief help message
    --man (-m)               man page. Similar to "perldoc raxref"
    --conf=file (-c file)    config file. Defaults to "raxref.conf"
    --all (-a)               rebuild all sections
    --outpath=path (-o path) output path. Defaults to "output"
                             (overrides conf file directive "output_path")
    --quiet (-q)             omit console output

Use C<raxref --man> for more information.
                                                   
=head1 DESCRIPTION

B<Raxref> was originally written to build a browsable cross reference
for the Parrot project. But you may use it for any project, because it's
not Parrot-specific at all, except that there's a bundled config file
suitable for Parrot.

The default config file is F<raxref.conf>.

To force a build of certain sections, add them to the command line, or
use the C<--all> switch to rebuild everything. C<--all> will also rebuild
all caches.

=head2 CONFIG FILES

The config files describe your project repository. Usually two lines
will be sufficient:

  include conf/std.conf
  source myproject /home/me/projects/myproject
                                                        
This tells raxref that you want to use the standard filtetype
definitions from 'std.conf' and where to find the sources of your
project.

Running B<raxref -c myproject.conf> will produce the cross reference
information and store it in the directory F<output>.

If you want to describe your project in more detail, this are the
directives that B<Raxref> will accept in conf files:

=over

=item C<project name title>

Tells B<Raxref> how you call your project. The project identifier
C<name> is used for file names and such, so keep it unique. The C<title>
is in the UI.

=item C<source name path>

This is where your source code lives. You can have multiple C<source>
directives. Parameters of the C<includes> and C<excludes> directives
must then be prefixed with the C<source> name followed by a colon, e.g.
C<includes inclsrc:/includes>.

=item C<output_path path>

TBD

=item C<token_threshold value>

TBD

=item C<section name title>

TBD

=item C<omit>

TBD

=item C<includes path>

TBD

=item C<excludes path>

TBD

=item C<filetype name title>

TBD

=item C<keywords keyword1 keyword2 ...>

TBD

=item C<keywords_from filetype>

TBD

=item C<file_re regex>

TBD

=item C<tokens_exclude_re>

TBD

=item C<tokens_include_re>

TBD

=back

=head1 SHAMELESS PLUG

If you like this product, you may also like rabak (http://www.raisin.de/rabak),
a powerful, rsync based backup solution.
                                                                           
=cut
